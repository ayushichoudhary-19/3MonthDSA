# Problem: Next Permutation

# Approach 1: Brute Force - Finding the Next Permutation üßê

### Intuition ü§î
We want to find the next lexicographically greater permutation of an array of integers, `nums`.

### Approach üõ†Ô∏è
The brute force solution has three steps:
1. Find all possible permutations of given array `nums`.
2. Linearly search for the given permutation.
3. Return the very next permutation of the given found permutation.

### Time Complexity ‚è≥
- **Generating All Permutations:** Generating all permutations of an array with N elements has a time complexity of O(N!). This is because there are N! (N factorial) possible permutations of an array of size N.

- **Finding a Particular Arrangement Linearly:** After generating all permutations, you would need to linearly search for a particular arrangement. This search would also take O(N!) time in the worst case because you might need to go through all permutations to find the desired one.

- **Returning the Next Permutation of the Found Permutation:** Once you've found the desired permutation, finding the next permutation of it would also take O(N) time because you need to follow the steps for finding the next permutation on that specific permutation.

Thus, the time complexity of this approach would be O(N!) due to the generation of all permutations. It's an inefficient approach, especially for large values of N, and is likely to give a **TLE**.

### Space Complexity üöÄ
The space complexity for generating all permutations of an array with N elements is O(N!) because you're storing N! different permutations.

# Approach 2: Better Solution (only for cpp users) - Using next_permutation() funüßê

### Approach üõ†Ô∏è
We can use the `next_permutation()` function. The next_permutation function is a part of the C++ Standard Library's `<algorithm>` header. It's used to generate the next lexicographically greater permutation of a vector.

### Time Complexity ‚è≥
The time complexity of the `next_permutation()` function is O(N), where N is the size of the input vector (nums in this case).
The function traverses the vector from right to left to find the first pair of two consecutive elements such that the left element is less than the right element. This operation takes O(N) time in the worst case.
The subsequent operations, such as finding the smallest greater element and reversing the subarray, also take O(N) time in total.
So, the overall time complexity is O(N).

### Space Complexity üöÄ
The next_permutation function operates in-place and does not use any additional memory that scales with the input size. Therefore, the space complexity of the nextPermutation function is O(1), which means it uses constant extra memory.

### Code üíª
<a href="https://github.com/ayushichoudhary-19/3MonthDSA/blob/main/Arrays/Medium/31.%20Next%20Permutation/31-Approach2.cpp"> Click here </a>

# Liked the Solutions?
- **UPVOTE üëç MY SOLUTION ON LEETCODE**: <a href="https://leetcode.com/problems/next-permutation/solutions/4079304/3-approaches-well-explained-bruteforce-better-optimized/" > Here </a>
- **Star ‚≠êÔ∏è this repository!**

